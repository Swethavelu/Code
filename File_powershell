# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $outputFileName = $row.'Output Filename(s)'

        # Construct the full file path
        $filePath = Join-Path -Path $folderPath -ChildPath $outputFileName

        # Check if the file exists
        if (Test-Path $filePath -PathType Leaf) {
            # Copy the file to the destination path
            $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $outputFileName
            Copy-Item -Path $filePath -Destination $destinationFilePath -Force

            # Get file size
            $fileInfo = Get-Item -Path $destinationFilePath
            $fileSize = $fileInfo.Length

            # Print the file name and size
            Write-Host "File copied: $($outputFileName), Size: $($fileSize) bytes"
        } else {
            Write-Warning "File $($outputFileName) does not exist in folder path: $($folderPath)"
        }
    }
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}


version 2
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to replace placeholders in file name
function Resolve-FilenamePlaceholders {
    param (
        [string]$fileNamePattern
    )
    
    # Replace date and time placeholders
    $resolvedFileName = $fileNamePattern -replace '\[date\|([^\]]+)\]', { (Get-Date).ToString($args[0].Groups[1].Value) }
    $resolvedFileName = $resolvedFileName -replace '\[Time\|([^\]]+)\]', { (Get-Date).ToString($args[0].Groups[1].Value) }
    
    return $resolvedFileName
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $fileNamePattern = $row.'Output Filename(s)'

        # Resolve the file name pattern
        $resolvedFileName = Resolve-FilenamePlaceholders -fileNamePattern $fileNamePattern

        # Construct the full file path
        $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

        # Check if the file exists
        if (Test-Path $filePath -PathType Leaf) {
            # Copy the file to the destination path
            $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
            Copy-Item -Path $filePath -Destination $destinationFilePath -Force

            # Get file size
            $fileInfo = Get-Item -Path $destinationFilePath
            $fileSize = $fileInfo.Length

            # Print the file name and size
            Write-Host "File copied: $($resolvedFileName), Size: $($fileSize) bytes"
        } else {
            Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
        }
    }
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}


version 3
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Specify the business date
$businessDate = "20240531" # Example: YYYYMMDD format

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with business date
function Resolve-FilenamePlaceholders {
    param (
        [string]$fileNamePattern,
        [string]$businessDate,
        [string]$latestTimeStamp
    )
    
    # Replace date and time placeholders
    $resolvedFileName = $fileNamePattern -replace '\[date\|([^\]]+)\]', $businessDate
    $resolvedFileName = $resolvedFileName -replace '\[Time\|([^\]]+)\]', $latestTimeStamp
    
    return $resolvedFileName
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $fileNamePattern = $row.'Output Filename(s)'

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder
            $files = Get-ChildItem -Path $folderPath

            # Find the latest timestamp file in the folder
            $latestFile = $files | Sort-Object LastWriteTime -Descending | Select-Object -First 1

            if ($latestFile) {
                # Extract the latest timestamp in HHmmss format
                $latestTimeStamp = $latestFile.LastWriteTime.ToString("HHmmss")

                # Resolve the file name pattern
                $resolvedFileName = Resolve-FilenamePlaceholders -fileNamePattern $fileNamePattern -businessDate $businessDate -latestTimeStamp $latestTimeStamp

                # Construct the full file path
                $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                # Check if the file exists
                if (Test-Path $filePath -PathType Leaf) {
                    # Copy the file to the destination path
                    $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                    Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                    # Get file size
                    $fileInfo = Get-Item -Path $destinationFilePath
                    $fileSize = $fileInfo.Length

                    # Print the file name and size
                    Write-Host "File copied: $($resolvedFileName), Size: $($fileSize) bytes"
                } else {
                    Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                }
            } else {
                Write-Warning "No files found in folder path: $($folderPath)"
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."
        }
    }
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}

version 4
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Specify the business date
$businessDate = "20240531" # Example: YYYYMMDD format

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Function to resolve the file name pattern with business date
function Resolve-FilenamePlaceholders {
    param (
        [string]$fileNamePattern,
        [string]$businessDate,
        [string]$latestTimeStamp
    )
    
    # Replace date and time placeholders
    $resolvedFileName = $fileNamePattern -replace '\[date\|([^\]]+)\]', $businessDate
    $resolvedFileName = $resolvedFileName -replace '\[Time\|([^\]]+)\]', $latestTimeStamp
    
    return $resolvedFileName
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $fileNamePattern = $row.'Output Filename(s)'

        # Initialize default values for the new columns
        $fileStatus = "File Not Found"
        $fileSize = 0
        $fileComparisonStatus = "Data Not Found"

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder
            $files = Get-ChildItem -Path $folderPath

            # Find the latest timestamp file in the folder
            $latestFile = $files | Sort-Object LastWriteTime -Descending | Select-Object -First 1

            if ($latestFile) {
                # Extract the latest timestamp in HHmmss format
                $latestTimeStamp = $latestFile.LastWriteTime.ToString("HHmmss")

                # Resolve the file name pattern
                $resolvedFileName = Resolve-FilenamePlaceholders -fileNamePattern $fileNamePattern -businessDate $businessDate -latestTimeStamp $latestTimeStamp

                # Construct the full file path
                $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                # Check if the file exists
                if (Test-Path $filePath -PathType Leaf) {
                    # Copy the file to the destination path
                    $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                    Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                    # Get file size
                    $fileInfo = Get-Item -Path $destinationFilePath
                    $fileSize = [math]::Round($fileInfo.Length / 1KB, 2)

                    # Update file status and comparison status based on file size
                    if ($fileSize -eq 0) {
                        $fileComparisonStatus = "Data Not Found"
                    } elseif ($fileSize -eq 1) {
                        $fileComparisonStatus = "Only Headers Found"
                    } else {
                        $fileComparisonStatus = "File Ready for Comparison"
                    }

                    $fileStatus = "File Present"
                } else {
                    Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                }
            } else {
                Write-Warning "No files found in folder path: $($folderPath)"
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."
        }

        # Update the row with new column values
        $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
        $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
        $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

        # Add updated row to the list
        $updatedRows += $row
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}

version 5
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Specify the business date
$businessDate = "20240531" # Example: YYYYMMDD format

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with business date
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern,
        [string]$businessDate
    )
    
    # Replace date placeholder
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|([^\]]+)\]', $businessDate
    
    # Replace time placeholder with wildcard
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|([^\]]+)\]', '*'
    
    return $resolvedFileNamePattern
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $fileNamePattern = $row.'Output Filename(s)'

        # Initialize default values for the new columns
        $fileStatus = "File Not Found"
        $fileSize = 0
        $fileComparisonStatus = "Data Not Found"

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Resolve the file name pattern
            $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern -businessDate $businessDate

            # Search for files that match the resolved pattern
            $matchingFiles = Get-ChildItem -Path $folderPath -Filter $resolvedFileNamePattern

            # Find the latest timestamp file in the folder
            $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

            if ($latestFile) {
                # Extract the latest timestamp in HHmmss format
                $latestTimeStamp = $latestFile.LastWriteTime.ToString("HHmmss")

                # Construct the final resolved file name
                $resolvedFileName = $fileNamePattern -replace '\[date\|([^\]]+)\]', $businessDate
                $resolvedFileName = $resolvedFileName -replace '\[Time\|([^\]]+)\]', $latestTimeStamp

                # Construct the full file path
                $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                # Check if the file exists
                if (Test-Path $filePath -PathType Leaf) {
                    # Copy the file to the destination path
                    $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                    Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                    # Get file size
                    $fileInfo = Get-Item -Path $destinationFilePath
                    $fileSize = [math]::Round($fileInfo.Length / 1KB, 2)

                    # Update file status and comparison status based on file size
                    if ($fileSize -eq 0) {
                        $fileComparisonStatus = "Data Not Found"
                    } elseif ($fileSize -eq 1) {
                        $fileComparisonStatus = "Only Headers Found"
                    } else {
                        $fileComparisonStatus = "File Ready for Comparison"
                    }

                    $fileStatus = "File Present"
                } else {
                    Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                }
            } else {
                Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."
        }

        # Update the row with new column values
        $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
        $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
        $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

        # Add updated row to the list
        $updatedRows += $row
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}
version 6
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Iterate through each row in the CSV
    foreach ($row in $csvData) {
        $folderPath = $row.FolderPath
        $fileNamePattern = $row.'Output Filename(s)'

        # Initialize default values for the new columns
        $fileStatus = "File Not Found"
        $fileSize = 0
        $fileComparisonStatus = "Data Not Found"

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Resolve the file name pattern
            $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

            # Search for files that match the resolved pattern
            $matchingFiles = Get-ChildItem -Path $folderPath -Filter $resolvedFileNamePattern

            # Find the latest timestamp file in the folder
            $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

            if ($latestFile) {
                # Extract the latest timestamp in HHmmss format
                $latestTimeStamp = $latestFile.LastWriteTime.ToString("HHmmss")

                # Construct the final resolved file name
                $resolvedFileName = $latestFile.Name

                # Construct the full file path
                $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                # Check if the file exists
                if (Test-Path $filePath -PathType Leaf) {
                    # Copy the file to the destination path
                    $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                    Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                    # Get file size
                    $fileInfo = Get-Item -Path $destinationFilePath
                    $fileSize = [math]::Round($fileInfo.Length / 1KB, 2)

                    # Update file status and comparison status based on file size
                    if ($fileSize -eq 0) {
                        $fileComparisonStatus = "Data Not Found"
                    } elseif ($fileSize -eq 1) {
                        $fileComparisonStatus = "Only Headers Found"
                    } else {
                        $fileComparisonStatus = "File Ready for Comparison"
                    }

                    $fileStatus = "File Present"
                } else {
                    Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                }
            } else {
                Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."
        }

        # Update the row with new column values
        $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
        $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
        $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

        # Add updated row to the list
        $updatedRows += $row
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}

version 7
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Group CSV data by folder path to minimize redundant directory scans
    $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

    # Iterate through each folder group
    foreach ($folderGroup in $csvDataGroupedByFolderPath) {
        $folderPath = $folderGroup.Name
        $rows = $folderGroup.Group

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder once
            $allFiles = Get-ChildItem -Path $folderPath

            # Iterate through each row in the group
            foreach ($row in $rows) {
                $fileNamePattern = $row.'Output Filename(s)'

                # Initialize default values for the new columns
                $fileStatus = "File Not Found"
                $fileSize = 0
                $fileComparisonStatus = "Data Not Found"

                # Resolve the file name pattern
                $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                # Search for files that match the resolved pattern
                $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                # Find the latest timestamp file in the folder
                $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                if ($latestFile) {
                    # Construct the final resolved file name
                    $resolvedFileName = $latestFile.Name

                    # Construct the full file path
                    $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                    # Check if the file exists
                    if (Test-Path $filePath -PathType Leaf) {
                        # Copy the file to the destination path
                        $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                        Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                        # Get file size
                        $fileInfo = Get-Item -Path $destinationFilePath
                        $fileSize = [math]::Round($fileInfo.Length / 1KB)

                        # Update file status and comparison status based on file size
                        if ($fileSize -eq 0) {
                            $fileComparisonStatus = "Data Not Found"
                        } elseif ($fileSize -eq 1) {
                            $fileComparisonStatus = "Only Headers Found"
                        } else {
                            $fileComparisonStatus = "File Ready for Comparison"
                        }

                        $fileStatus = "File Present"
                    } else {
                        Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                    }
                } else {
                    Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                }

                # Update the row with new column values
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                # Add updated row to the list
                $updatedRows += $row
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."

            # Update the rows with new column values for non-existent folder
            foreach ($row in $rows) {
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                $updatedRows += $row
            }
        }
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath' and/or 'Output Filename(s)' not found in the CSV file."
}
version 8
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'ID') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Group CSV data by folder path to minimize redundant directory scans
    $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

    # Iterate through each folder group
    foreach ($folderGroup in $csvDataGroupedByFolderPath) {
        $folderPath = $folderGroup.Name
        $rows = $folderGroup.Group

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder once
            $allFiles = Get-ChildItem -Path $folderPath

            # Iterate through each row in the group
            foreach ($row in $rows) {
                $fileNamePattern = $row.'Output Filename(s)'
                $id = $row.ID

                # Initialize default values for the new columns
                $fileStatus = "File Not Found"
                $fileSize = 0
                $fileComparisonStatus = "Data Not Found"

                # Resolve the file name pattern
                $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                # Search for files that match the resolved pattern
                $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                # Find the latest timestamp file in the folder
                $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                if ($latestFile) {
                    # Construct the final resolved file name
                    $resolvedFileName = $latestFile.Name

                    # Construct the full file path
                    $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                    # Check if the file exists
                    if (Test-Path $filePath -PathType Leaf) {
                        # Copy the file to the destination path
                        $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                        Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                        # Get file size
                        $fileInfo = Get-Item -Path $destinationFilePath
                        $fileSize = [math]::Round($fileInfo.Length / 1KB)

                        # Update file status and comparison status based on file size
                        if ($fileSize -eq 0) {
                            $fileComparisonStatus = "Data Not Found"
                        } elseif ($fileSize -eq 1) {
                            $fileComparisonStatus = "Only Headers Found"
                        } else {
                            $fileComparisonStatus = "File Ready for Comparison"
                        }

                        $fileStatus = "File Present"

                        # Rename the file to include the ID
                        $newFileName = "{0}_{1}{2}" -f [System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName), $id, [System.IO.Path]::GetExtension($resolvedFileName)
                        $newFilePath = Join-Path -Path $destinationPath -ChildPath $newFileName
                        Rename-Item -Path $destinationFilePath -NewName $newFileName
                    } else {
                        Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                    }
                } else {
                    Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                }

                # Update the row with new column values
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                # Add updated row to the list
                $updatedRows += $row
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."

            # Update the rows with new column values for non-existent folder
            foreach ($row in $rows) {
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                $updatedRows += $row
            }
        }
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', and/or 'ID' not found in the CSV file."
}

verion 9
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'ID') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Group CSV data by folder path to minimize redundant directory scans
    $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

    # Iterate through each folder group
    foreach ($folderGroup in $csvDataGroupedByFolderPath) {
        $folderPath = $folderGroup.Name
        $rows = $folderGroup.Group

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder once
            $allFiles = Get-ChildItem -Path $folderPath

            # Iterate through each row in the group
            foreach ($row in $rows) {
                $fileNamePattern = $row.'Output Filename(s)'
                $id = $row.ID

                # Initialize default values for the new columns
                $fileStatus = "File Not Found"
                $fileSize = 0
                $fileComparisonStatus = "Data Not Found"

                # Resolve the file name pattern
                $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                # Search for files that match the resolved pattern
                $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                # Find the latest timestamp file in the folder
                $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                if ($latestFile) {
                    # Construct the final resolved file name
                    $resolvedFileName = $latestFile.Name

                    # Construct the full file path
                    $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                    # Check if the file exists
                    if (Test-Path $filePath -PathType Leaf) {
                        # Copy the file to the destination path
                        $destinationFilePath = Join-Path -Path $destinationPath -ChildPath $resolvedFileName
                        Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                        # Get file size
                        $fileInfo = Get-Item -Path $destinationFilePath
                        $fileSize = [math]::Round($fileInfo.Length / 1KB)

                        # Update file status and comparison status based on file size
                        if ($fileSize -eq 0) {
                            $fileComparisonStatus = "Data Not Found"
                        } elseif ($fileSize -eq 1) {
                            $fileComparisonStatus = "Only Headers Found"
                        } else {
                            $fileComparisonStatus = "File Ready for Comparison"
                        }

                        $fileStatus = "File Present"

                        # Remove timestamp from the original file name
                        $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                        $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                        # Rename the file to include the ID
                        $newFileName = "{0}_{1}{2}" -f $baseFileName, $id, $extension
                        $newFilePath = Join-Path -Path $destinationPath -ChildPath $newFileName
                        Rename-Item -Path $destinationFilePath -NewName $newFileName
                    } else {
                        Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                    }
                } else {
                    Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                }

                # Update the row with new column values
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSize) KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                # Add updated row to the list
                $updatedRows += $row
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."

            # Update the rows with new column values for non-existent folder
            foreach ($row in $rows) {
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                $updatedRows += $row
            }
        }
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', and/or 'ID' not found in the CSV file."
}

June 20 2024
# Specify the input CSV file path
$inputCSVPath = "C:\Path\to\input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Define subdirectories for XLSX and others
$xlsxFolder = Join-Path -Path $destinationPath -ChildPath "XLSX"
$othersFolder = Join-Path -Path $destinationPath -ChildPath "Others"

# Create subdirectories if they do not exist
if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
    New-Item -Path $xlsxFolder -ItemType Directory
}
if (-not (Test-Path -Path $othersFolder -PathType Container)) {
    New-Item -Path $othersFolder -ItemType Directory
}

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Read the CSV file
$csvData = Import-Csv -Path $inputCSVPath

# Debugging: Display column names
Write-Host "Column names in CSV file:"
$csvData[0].PSObject.Properties.Name

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Check if the required columns exist in the CSV data
if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId') {
    # Create a list to store updated rows
    $updatedRows = @()

    # Group CSV data by folder path to minimize redundant directory scans
    $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

    # Iterate through each folder group
    foreach ($folderGroup in $csvDataGroupedByFolderPath) {
        $folderPath = $folderGroup.Name
        $rows = $folderGroup.Group

        # Check if the folder path exists
        if (Test-Path $folderPath -PathType Container) {
            # Get all files in the folder once
            $allFiles = Get-ChildItem -Path $folderPath

            # Iterate through each row in the group
            foreach ($row in $rows) {
                $fileNamePattern = $row.'Output Filename(s)'
                $jobName = $row.JobName
                $feedId = $row.FeedId

                # Initialize default values for the new columns
                $fileStatus = "File Not Found"
                $fileSize = 0
                $fileComparisonStatus = "Data Not Found"

                # Resolve the file name pattern
                $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                # Search for files that match the resolved pattern
                $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                # Find the latest timestamp file in the folder
                $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                if ($latestFile) {
                    # Get file size in bytes
                    $fileSize = $latestFile.Length

                    # Check if file size is less than 10 GB
                    if ($fileSize -lt $maxFileSize) {
                        # Construct the final resolved file name
                        $resolvedFileName = $latestFile.Name

                        # Construct the full file path
                        $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                        # Check if the file exists
                        if (Test-Path $filePath -PathType Leaf) {
                            # Determine destination folder based on file extension
                            if ($latestFile.Extension -eq ".xlsx") {
                                $destinationFolder = $xlsxFolder
                            } else {
                                $destinationFolder = $othersFolder
                            }

                            # Copy the file to the destination folder
                            $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                            Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                            # Remove timestamp from the original file name
                            $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                            $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                            # Rename the file to include the JobName and FeedId
                            $newFileName = "{0}_{1}_{2}{3}" -f $baseFileName, $jobName, $feedId, $extension
                            $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                            Rename-Item -Path $destinationFilePath -NewName $newFileName

                            $fileStatus = "File Present"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            if ($fileSizeKB -eq 0) {
                                $fileComparisonStatus = "Data Not Found"
                            } elseif ($fileSizeKB -eq 1) {
                                $fileComparisonStatus = "Only Headers Found"
                            } else {
                                $fileComparisonStatus = "File Ready for Comparison"
                            }
                        } else {
                            Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                        }
                    } else {
                        $fileStatus = "File Exceeds Size Limit"
                        $fileSizeKB = [math]::Round($fileSize / 1KB)
                        $fileComparisonStatus = "File Too Large to Process"
                    }
                } else {
                    Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                }

                # Update the row with new column values
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                # Add updated row to the list
                $updatedRows += $row
            }
        } else {
            Write-Warning "Folder path $($folderPath) does not exist."

            # Update the rows with new column values for non-existent folder
            foreach ($row in $rows) {
                $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                $updatedRows += $row
            }
        }
    }

    # Export the updated CSV
    $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
} else {
    Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', and/or 'FeedId' not found in the CSV file."
}

version 2
# Specify the input CSV file paths
$bauInputCSVPath = "C:\Path\to\bau_input.csv"
$conv4InputCSVPath = "C:\Path\to\conv4_input.csv"

# Specify the default destination path
$destinationPath = "C:\Destination\"

# Define subdirectories for XLSX and others
$xlsxFolder = Join-Path -Path $destinationPath -ChildPath "XLSX"
$othersFolder = Join-Path -Path $destinationPath -ChildPath "Others"

# Create subdirectories if they do not exist
if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
    New-Item -Path $xlsxFolder -ItemType Directory
}
if (-not (Test-Path -Path $othersFolder -PathType Container)) {
    New-Item -Path $othersFolder -ItemType Directory
}

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Function to process an input CSV file
function Process-InputCSV {
    param (
        [string]$inputCSVPath
    )

    # Read the CSV file
    $csvData = Import-Csv -Path $inputCSVPath

    # Debugging: Display column names
    Write-Host "Column names in CSV file ($inputCSVPath):"
    $csvData[0].PSObject.Properties.Name

    # Check if the required columns exist in the CSV data
    if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId') {
        # Create a list to store updated rows
        $updatedRows = @()

        # Group CSV data by folder path to minimize redundant directory scans
        $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

        # Iterate through each folder group
        foreach ($folderGroup in $csvDataGroupedByFolderPath) {
            $folderPath = $folderGroup.Name
            $rows = $folderGroup.Group

            # Check if the folder path exists
            if (Test-Path $folderPath -PathType Container) {
                # Get all files in the folder once
                $allFiles = Get-ChildItem -Path $folderPath

                # Iterate through each row in the group
                foreach ($row in $rows) {
                    $fileNamePattern = $row.'Output Filename(s)'
                    $jobName = $row.JobName
                    $feedId = $row.FeedId

                    # Initialize default values for the new columns
                    $fileStatus = "File Not Found"
                    $fileSize = 0
                    $fileComparisonStatus = "Data Not Found"

                    # Resolve the file name pattern
                    $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                    # Search for files that match the resolved pattern
                    $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                    # Find the latest timestamp file in the folder
                    $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                    if ($latestFile) {
                        # Get file size in bytes
                        $fileSize = $latestFile.Length

                        # Check if file size is less than 10 GB
                        if ($fileSize -lt $maxFileSize) {
                            # Construct the final resolved file name
                            $resolvedFileName = $latestFile.Name

                            # Construct the full file path
                            $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                            # Check if the file exists
                            if (Test-Path $filePath -PathType Leaf) {
                                # Determine destination folder based on file extension
                                if ($latestFile.Extension -eq ".xlsx") {
                                    $destinationFolder = $xlsxFolder
                                } else {
                                    $destinationFolder = $othersFolder
                                }

                                # Copy the file to the destination folder
                                $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                                Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                                # Remove timestamp from the original file name
                                $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                                $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                                # Rename the file to include the JobName and FeedId
                                $newFileName = "{0}_{1}_{2}{3}" -f $baseFileName, $jobName, $feedId, $extension
                                $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                                Rename-Item -Path $destinationFilePath -NewName $newFileName

                                $fileStatus = "File Present"
                                $fileSizeKB = [math]::Round($fileSize / 1KB)
                                if ($fileSizeKB -eq 0) {
                                    $fileComparisonStatus = "Data Not Found"
                                } elseif ($fileSizeKB -eq 1) {
                                    $fileComparisonStatus = "Only Headers Found"
                                } else {
                                    $fileComparisonStatus = "File Ready for Comparison"
                                }
                            } else {
                                Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                            }
                        } else {
                            $fileStatus = "File Exceeds Size Limit"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            $fileComparisonStatus = "File Too Large to Process"
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                }
            } else {
                Write-Warning "Folder path $($folderPath) does not exist."

                # Update the rows with new column values for non-existent folder
                foreach ($row in $rows) {
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                    $updatedRows += $row
                }
            }
        }

        # Export the updated CSV
        $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
    } else {
        Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', and/or 'FeedId' not found in the CSV file."
    }
}

# Process both input CSV files
Process-InputCSV -inputCSVPath $bauInputCSVPath
Process-InputCSV -inputCSVPath $conv4InputCSVPath

version 3:
# Specify the input CSV file paths
$bauInputCSVPath = "C:\Path\to\bau_input.csv"
$conv4InputCSVPath = "C:\Path\to\conv4_input.csv"

# Specify the destination paths
$bauDestinationPath = "C:\Destination\BAU"
$conv4DestinationPath = "C:\Destination\CONV4"

# Define a function to create subdirectories for XLSX and Others within a specified path
function Ensure-Subdirectories {
    param (
        [string]$basePath
    )

    $xlsxFolder = Join-Path -Path $basePath -ChildPath "XLSX"
    $othersFolder = Join-Path -Path $basePath -ChildPath "Others"

    if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
        New-Item -Path $xlsxFolder -ItemType Directory
    }
    if (-not (Test-Path -Path $othersFolder -PathType Container)) {
        New-Item -Path $othersFolder -ItemType Directory
    }

    return @{ XLSXFolder = $xlsxFolder; OthersFolder = $othersFolder }
}

# Ensure subdirectories for both destination paths
$bauFolders = Ensure-Subdirectories -basePath $bauDestinationPath
$conv4Folders = Ensure-Subdirectories -basePath $conv4DestinationPath

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Function to process an input CSV file
function Process-InputCSV {
    param (
        [string]$inputCSVPath,
        [string]$destinationPath,
        [hashtable]$folders
    )

    # Read the CSV file
    $csvData = Import-Csv -Path $inputCSVPath

    # Debugging: Display column names
    Write-Host "Column names in CSV file ($inputCSVPath):"
    $csvData[0].PSObject.Properties.Name

    # Check if the required columns exist in the CSV data
    if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId') {
        # Create a list to store updated rows
        $updatedRows = @()

        # Group CSV data by folder path to minimize redundant directory scans
        $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

        # Iterate through each folder group
        foreach ($folderGroup in $csvDataGroupedByFolderPath) {
            $folderPath = $folderGroup.Name
            $rows = $folderGroup.Group

            # Check if the folder path exists
            if (Test-Path $folderPath -PathType Container) {
                # Get all files in the folder once
                $allFiles = Get-ChildItem -Path $folderPath

                # Iterate through each row in the group
                foreach ($row in $rows) {
                    $fileNamePattern = $row.'Output Filename(s)'
                    $jobName = $row.JobName
                    $feedId = $row.FeedId

                    # Initialize default values for the new columns
                    $fileStatus = "File Not Found"
                    $fileSize = 0
                    $fileComparisonStatus = "Data Not Found"

                    # Resolve the file name pattern
                    $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                    # Search for files that match the resolved pattern
                    $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                    # Find the latest timestamp file in the folder
                    $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                    if ($latestFile) {
                        # Get file size in bytes
                        $fileSize = $latestFile.Length

                        # Check if file size is less than 10 GB
                        if ($fileSize -lt $maxFileSize) {
                            # Construct the final resolved file name
                            $resolvedFileName = $latestFile.Name

                            # Construct the full file path
                            $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                            # Check if the file exists
                            if (Test-Path $filePath -PathType Leaf) {
                                # Determine destination folder based on file extension
                                if ($latestFile.Extension -eq ".xlsx") {
                                    $destinationFolder = $folders.XLSXFolder
                                } else {
                                    $destinationFolder = $folders.OthersFolder
                                }

                                # Copy the file to the destination folder
                                $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                                Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                                # Remove timestamp from the original file name
                                $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                                $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                                # Rename the file to include the JobName and FeedId
                                $newFileName = "{0}_{1}_{2}{3}" -f $baseFileName, $jobName, $feedId, $extension
                                $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                                Rename-Item -Path $destinationFilePath -NewName $newFileName

                                $fileStatus = "File Present"
                                $fileSizeKB = [math]::Round($fileSize / 1KB)
                                if ($fileSizeKB -eq 0) {
                                    $fileComparisonStatus = "Data Not Found"
                                } elseif ($fileSizeKB -eq 1) {
                                    $fileComparisonStatus = "Only Headers Found"
                                } else {
                                    $fileComparisonStatus = "File Ready for Comparison"
                                }
                            } else {
                                Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                            }
                        } else {
                            $fileStatus = "File Exceeds Size Limit"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            $fileComparisonStatus = "File Too Large to Process"
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                }
            } else {
                Write-Warning "Folder path $($folderPath) does not exist."

                # Update the rows with new column values for non-existent folder
                foreach ($row in $rows) {
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                    $updatedRows += $row
                }
            }
        }

        # Export the updated CSV
        $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
    } else {
        Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', and/or 'FeedId' not found in the CSV file."
    }
}

# Process BAU Input CSV
Process-InputCSV -inputCSVPath $bauInputCSVPath -destinationPath $bauDestinationPath -folders $bauFolders

# Process CONV4 Input CSV
Process-InputCSV -inputCSVPath $conv4InputCSVPath -destinationPath $conv4DestinationPath -folders $conv4Folders

version 4:
# Specify the input CSV file paths
$bauInputCSVPath = "C:\Path\to\bau_input.csv"
$conv4InputCSVPath = "C:\Path\to\conv4_input.csv"

# Specify the destination paths
$bauDestinationPath = "C:\Destination\BAU"
$conv4DestinationPath = "C:\Destination\CONV4"

# Define a function to create subdirectories for XLSX and Others within a specified path
function Ensure-Subdirectories {
    param (
        [string]$basePath
    )

    $xlsxFolder = Join-Path -Path $basePath -ChildPath "XLSX"
    $othersFolder = Join-Path -Path $basePath -ChildPath "Others"

    if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
        New-Item -Path $xlsxFolder -ItemType Directory
    }
    if (-not (Test-Path -Path $othersFolder -PathType Container)) {
        New-Item -Path $othersFolder -ItemType Directory
    }

    return @{ XLSXFolder = $xlsxFolder; OthersFolder = $othersFolder }
}

# Ensure subdirectories for both destination paths
$bauFolders = Ensure-Subdirectories -basePath $bauDestinationPath
$conv4Folders = Ensure-Subdirectories -basePath $conv4DestinationPath

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Function to process an input CSV file
function Process-InputCSV {
    param (
        [string]$inputCSVPath,
        [string]$destinationPath,
        [hashtable]$folders
    )

    # Read the CSV file
    $csvData = Import-Csv -Path $inputCSVPath

    # Debugging: Display column names
    Write-Host "Column names in CSV file ($inputCSVPath):"
    $csvData[0].PSObject.Properties.Name

    # Check if the required columns exist in the CSV data
    if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId') {
        # Create a list to store updated rows
        $updatedRows = @()

        # Group CSV data by folder path to minimize redundant directory scans
        $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

        # Iterate through each folder group
        foreach ($folderGroup in $csvDataGroupedByFolderPath) {
            $folderPath = $folderGroup.Name
            $rows = $folderGroup.Group

            # Check if the folder path exists
            if (Test-Path $folderPath -PathType Container) {
                # Get all files in the folder once
                $allFiles = Get-ChildItem -Path $folderPath

                # Iterate through each row in the group
                foreach ($row in $rows) {
                    $fileNamePattern = $row.'Output Filename(s)'
                    $jobName = $row.JobName
                    $feedId = $row.FeedId

                    # Initialize default values for the new columns
                    $fileStatus = "File Not Found"
                    $fileSize = 0
                    $fileComparisonStatus = "Data Not Found"

                    # Resolve the file name pattern
                    $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                    # Search for files that match the resolved pattern
                    $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                    # Find the latest timestamp file in the folder
                    $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                    if ($latestFile) {
                        # Get file size in bytes
                        $fileSize = $latestFile.Length

                        # Check if file size is less than 10 GB
                        if ($fileSize -lt $maxFileSize) {
                            # Construct the final resolved file name
                            $resolvedFileName = $latestFile.Name

                            # Construct the full file path
                            $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                            # Check if the file exists
                            if (Test-Path $filePath -PathType Leaf) {
                                # Determine destination folder based on file extension
                                if ($latestFile.Extension -eq ".xlsx") {
                                    $destinationFolder = $folders.XLSXFolder
                                } else {
                                    $destinationFolder = $folders.OthersFolder
                                }

                                # Copy the file to the destination folder
                                $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                                Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                                # Remove timestamp from the original file name
                                $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                                $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                                # Rename the file to include only JobName, FeedId, and extension
                                $newFileName = "{0}_{1}{2}" -f $jobName, $feedId, $extension
                                $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                                Rename-Item -Path $destinationFilePath -NewName $newFileName

                                $fileStatus = "File Present"
                                $fileSizeKB = [math]::Round($fileSize / 1KB)
                                if ($fileSizeKB -eq 0) {
                                    $fileComparisonStatus = "Data Not Found"
                                } elseif ($fileSizeKB -eq 1) {
                                    $fileComparisonStatus = "Only Headers Found"
                                } else {
                                    $fileComparisonStatus = "File Ready for Comparison"
                                }
                            } else {
                                Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                            }
                        } else {
                            $fileStatus = "File Exceeds Size Limit"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            $fileComparisonStatus = "File Too Large to Process"
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                }
            } else {
                Write-Warning "Folder path $($folderPath) does not exist."

                # Update the rows with new column values for non-existent folder
                foreach ($row in $rows) {
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                    $updatedRows += $row
                }
            }
        }

        # Export the updated CSV
        $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
    } else {
        Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', and/or 'FeedId' not found in the CSV file."
    }
}

# Process BAU Input CSV
Process-InputCSV -inputCSVPath $bauInputCSVPath -destinationPath $bauDestinationPath -folders $bauFolders

# Process CONV4 Input CSV
Process-InputCSV -inputCSVPath $conv4InputCSVPath -destinationPath $conv4DestinationPath -folders $conv4Folders

version 5:
# Specify the input CSV file paths
$bauInputCSVPath = "C:\Path\to\bau_input.csv"
$conv4InputCSVPath = "C:\Path\to\conv4_input.csv"

# Specify the destination paths
$bauDestinationPath = "C:\Destination\BAU"
$conv4DestinationPath = "C:\Destination\CONV4"

# Define a function to create subdirectories for XLSX and Others within a specified path
function Ensure-Subdirectories {
    param (
        [string]$basePath
    )

    $xlsxFolder = Join-Path -Path $basePath -ChildPath "XLSX"
    $othersFolder = Join-Path -Path $basePath -ChildPath "Others"

    if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
        New-Item -Path $xlsxFolder -ItemType Directory
    }
    if (-not (Test-Path -Path $othersFolder -PathType Container)) {
        New-Item -Path $othersFolder -ItemType Directory
    }

    return @{ XLSXFolder = $xlsxFolder; OthersFolder = $othersFolder }
}

# Ensure subdirectories for both destination paths
$bauFolders = Ensure-Subdirectories -basePath $bauDestinationPath
$conv4Folders = Ensure-Subdirectories -basePath $conv4DestinationPath

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Function to process an input CSV file
function Process-InputCSV {
    param (
        [string]$inputCSVPath,
        [string]$destinationPath,
        [hashtable]$folders
    )

    # Read the CSV file
    $csvData = Import-Csv -Path $inputCSVPath

    # Debugging: Display column names
    Write-Host "Column names in CSV file ($inputCSVPath):"
    $csvData[0].PSObject.Properties.Name

    # Check if the required columns exist in the CSV data
    if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId') {
        # Create a list to store updated rows
        $updatedRows = @()

        # Group CSV data by folder path to minimize redundant directory scans
        $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

        # Iterate through each folder group
        foreach ($folderGroup in $csvDataGroupedByFolderPath) {
            $folderPath = $folderGroup.Name
            $rows = $folderGroup.Group

            # Check if the folder path exists
            if (Test-Path $folderPath -PathType Container) {
                # Get all files in the folder once
                $allFiles = Get-ChildItem -Path $folderPath

                # Iterate through each row in the group
                foreach ($row in $rows) {
                    $fileNamePattern = $row.'Output Filename(s)'
                    $jobName = $row.JobName
                    $feedId = $row.FeedId

                    # Initialize default values for the new columns
                    $fileStatus = "File Not Found"
                    $fileSize = 0
                    $fileComparisonStatus = "Data Not Found"

                    # Resolve the file name pattern
                    $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                    # Search for files that match the resolved pattern
                    $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                    # Find the latest timestamp file in the folder
                    $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                    if ($latestFile) {
                        # Get file size in bytes
                        $fileSize = $latestFile.Length

                        # Check if file size is less than 10 GB
                        if ($fileSize -lt $maxFileSize) {
                            # Construct the final resolved file name
                            $resolvedFileName = $latestFile.Name

                            # Construct the full file path
                            $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                            # Check if the file exists
                            if (Test-Path $filePath -PathType Leaf) {
                                # Determine destination folder based on file extension
                                if ($latestFile.Extension -eq ".xlsx") {
                                    $destinationFolder = $folders.XLSXFolder
                                } else {
                                    $destinationFolder = $folders.OthersFolder
                                }

                                # Copy the file to the destination folder
                                $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                                Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                                # Remove timestamp from the original file name
                                $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                                $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                                # Rename the file to include baseFileName, FeedId, and extension
                                $newFileName = "{0}_{1}{2}" -f $baseFileName, $feedId, $extension
                                $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                                Rename-Item -Path $destinationFilePath -NewName $newFileName

                                $fileStatus = "File Present"
                                $fileSizeKB = [math]::Round($fileSize / 1KB)
                                if ($fileSizeKB -eq 0) {
                                    $fileComparisonStatus = "Data Not Found"
                                } elseif ($fileSizeKB -eq 1) {
                                    $fileComparisonStatus = "Only Headers Found"
                                } else {
                                    $fileComparisonStatus = "File Ready for Comparison"
                                }
                            } else {
                                Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                            }
                        } else {
                            $fileStatus = "File Exceeds Size Limit"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            $fileComparisonStatus = "File Too Large to Process"
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                }
            } else {
                Write-Warning "Folder path $($folderPath) does not exist."

                # Update the rows with new column values for non-existent folder
                foreach ($row in $rows) {
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                    $updatedRows += $row
                }
            }
        }

        # Export the updated CSV
        $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
    } else {
        Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', and/or 'FeedId' not found in the CSV file."
    }
}

# Process BAU Input CSV
Process-InputCSV -inputCSVPath $bauInputCSVPath -destinationPath $bauDestinationPath -folders $bauFolders

# Process CONV4 Input CSV
Process-InputCSV -inputCSVPath $conv4InputCSVPath -destinationPath $conv4DestinationPath -folders $conv4Folders

Latest:
# Specify the input CSV file paths
$bauInputCSVPath = "C:\Path\to\bau_input.csv"
$conv4InputCSVPath = "C:\Path\to\conv4_input.csv"

# Specify the destination paths
$bauDestinationPath = "C:\Destination\BAU"
$conv4DestinationPath = "C:\Destination\CONV4"

# Define a function to create subdirectories for XLSX and Others within a specified path
function Ensure-Subdirectories {
    param (
        [string]$basePath
    )

    $xlsxFolder = Join-Path -Path $basePath -ChildPath "XLSX"
    $othersFolder = Join-Path -Path $basePath -ChildPath "Others"

    if (-not (Test-Path -Path $xlsxFolder -PathType Container)) {
        New-Item -Path $xlsxFolder -ItemType Directory
    }
    if (-not (Test-Path -Path $othersFolder -PathType Container)) {
        New-Item -Path $othersFolder -ItemType Directory
    }

    return @{ XLSXFolder = $xlsxFolder; OthersFolder = $othersFolder }
}

# Ensure subdirectories for both destination paths
$bauFolders = Ensure-Subdirectories -basePath $bauDestinationPath
$conv4Folders = Ensure-Subdirectories -basePath $conv4DestinationPath

# Maximum file size in bytes (10 GB)
$maxFileSize = 10 * 1024 * 1024 * 1024

# Function to resolve the file name pattern with wildcard for timestamp
function Resolve-FilenamePattern {
    param (
        [string]$fileNamePattern
    )
    
    # Replace placeholders with wildcards
    $resolvedFileNamePattern = $fileNamePattern -replace '\[date\|[^\]]+\]', '*'
    $resolvedFileNamePattern = $resolvedFileNamePattern -replace '\[Time\|[^\]]+\]', '*'
    
    return $resolvedFileNamePattern
}

# Function to remove timestamp from filename
function Remove-Timestamp {
    param (
        [string]$fileName
    )

    # Remove the timestamp pattern (assuming format YYYYMMDD_HHmmss or similar)
    $fileName -replace '\d{8}_\d{4}|\d{8}_\d{6}|\d{8}|\d{4}', ''
}

# Function to process an input CSV file
function Process-InputCSV {
    param (
        [string]$inputCSVPath,
        [string]$destinationPath,
        [hashtable]$folders
    )

    # Read the CSV file
    $csvData = Import-Csv -Path $inputCSVPath

    # Debugging: Display column names
    Write-Host "Column names in CSV file ($inputCSVPath):"
    $csvData[0].PSObject.Properties.Name

    # Check if the required columns exist in the CSV data
    if ($csvData[0].PSObject.Properties.Name -contains 'FolderPath' -and $csvData[0].PSObject.Properties.Name -contains 'Output Filename(s)' -and $csvData[0].PSObject.Properties.Name -contains 'JobName' -and $csvData[0].PSObject.Properties.Name -contains 'FeedId' -and $csvData[0].PSObject.Properties.Name -contains 'Description') {
        # Create a list to store updated rows
        $updatedRows = @()

        # Group CSV data by folder path to minimize redundant directory scans
        $csvDataGroupedByFolderPath = $csvData | Group-Object -Property FolderPath

        # Iterate through each folder group
        foreach ($folderGroup in $csvDataGroupedByFolderPath) {
            $folderPath = $folderGroup.Name
            $rows = $folderGroup.Group

            # Check if the folder path exists
            if (Test-Path $folderPath -PathType Container) {
                # Get all files in the folder once
                $allFiles = Get-ChildItem -Path $folderPath

                # Iterate through each row in the group
                foreach ($row in $rows) {
                    $fileNamePattern = $row.'Output Filename(s)'
                    $jobName = $row.JobName
                    $feedId = $row.FeedId
                    $description = $row.Description

                    # Initialize default values for the new columns
                    $fileStatus = "File Not Found"
                    $fileSize = 0
                    $fileComparisonStatus = "Data Not Found"

                    # Resolve the file name pattern
                    $resolvedFileNamePattern = Resolve-FilenamePattern -fileNamePattern $fileNamePattern

                    # Search for files that match the resolved pattern
                    $matchingFiles = $allFiles | Where-Object { $_.Name -like $resolvedFileNamePattern }

                    # Find the latest timestamp file in the folder
                    $latestFile = $matchingFiles | Sort-Object LastWriteTime -Descending | Select-Object -First 1

                    if ($latestFile) {
                        # Get file size in bytes
                        $fileSize = $latestFile.Length

                        # Check if file size is less than 10 GB
                        if ($fileSize -lt $maxFileSize) {
                            # Construct the final resolved file name
                            $resolvedFileName = $latestFile.Name

                            # Construct the full file path
                            $filePath = Join-Path -Path $folderPath -ChildPath $resolvedFileName

                            # Check if the file exists
                            if (Test-Path $filePath -PathType Leaf) {
                                # Determine destination folder based on file extension
                                if ($latestFile.Extension -eq ".xlsx") {
                                    $destinationFolder = $folders.XLSXFolder
                                } else {
                                    $destinationFolder = $folders.OthersFolder
                                }

                                # Copy the file to the destination folder
                                $destinationFilePath = Join-Path -Path $destinationFolder -ChildPath $resolvedFileName
                                Copy-Item -Path $filePath -Destination $destinationFilePath -Force

                                # Remove timestamp from the original file name
                                $baseFileName = Remove-Timestamp -fileName ([System.IO.Path]::GetFileNameWithoutExtension($resolvedFileName))
                                $extension = [System.IO.Path]::GetExtension($resolvedFileName)

                                # Rename the file to include DESCRIPTION, FeedId, and extension
                                $newFileName = "{0}_{1}{2}" -f $description, $feedId, $extension
                                $newFilePath = Join-Path -Path $destinationFolder -ChildPath $newFileName
                                Rename-Item -Path $destinationFilePath -NewName $newFileName

                                $fileStatus = "File Present"
                                $fileSizeKB = [math]::Round($fileSize / 1KB)
                                if ($fileSizeKB -eq 0) {
                                    $fileComparisonStatus = "Data Not Found"
                                } elseif ($fileSizeKB -eq 1) {
                                    $fileComparisonStatus = "Only Headers Found"
                                } else {
                                    $fileComparisonStatus = "File Ready for Comparison"
                                }
                            } else {
                                Write-Warning "File $($resolvedFileName) does not exist in folder path: $($folderPath)"
                            }
                        } else {
                            $fileStatus = "File Exceeds Size Limit"
                            $fileSizeKB = [math]::Round($fileSize / 1KB)
                            $fileComparisonStatus = "File Too Large to Process"
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: $($resolvedFileNamePattern)"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                }
            } else {
                Write-Warning "Folder path $($folderPath) does not exist."

                # Update the rows with new column values for non-existent folder
                foreach ($row in $rows) {
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                    $updatedRows += $row
                }
            }
        }

        # Export the updated CSV
        $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
    } else {
        Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', 'FeedId', and/or 'Description' not found in the CSV file."
    }
}
July 3
function Process-InputCSV {
    param (
        [string]$inputCSVPath,
        [string]$destinationPath,
        [array]$folders
    )

    if (Test-Path $inputCSVPath) {
        $rows = Import-Csv -Path $inputCSVPath
        $updatedRows = @()

        if ($rows -and $rows[0].PSObject.Properties.Match("FolderPath") -and $rows[0].PSObject.Properties.Match("Output Filename(s)") -and $rows[0].PSObject.Properties.Match("JobName") -and $rows[0].PSObject.Properties.Match("FeedId") -and $rows[0].PSObject.Properties.Match("Description")) {
            foreach ($folderPath in $folders) {
                if (Test-Path $folderPath) {
                    $files = Get-ChildItem -Path $folderPath -Recurse -Filter "*.xlsx"
                    $fileStatus = "File Not Found"
                    $fileComparisonStatus = "Data Not Found"
                    $fileSizeKB = 0

                    if ($files) {
                        foreach ($file in $files) {
                            if ($file.Length -le 10485760) { # 10 MB limit
                                $fileSizeKB = [math]::Round($file.Length / 1KB, 2)
                                $fileStatus = "File Found"
                                $fileComparisonStatus = "File Processed"

                                # Create new folders if they don't exist
                                $excelFolderPath = Join-Path -Path $destinationPath -ChildPath "ExcelFile"
                                $flatFileFolderPath = Join-Path -Path $destinationPath -ChildPath "FlatFile"
                                if (-not (Test-Path $excelFolderPath)) {
                                    New-Item -Path $excelFolderPath -ItemType Directory | Out-Null
                                }
                                if (-not (Test-Path $flatFileFolderPath)) {
                                    New-Item -Path $flatFileFolderPath -ItemType Directory | Out-Null
                                }

                                # Copy or move files to the appropriate folder
                                Copy-Item -Path $file.FullName -Destination $excelFolderPath
                            } else {
                                $fileComparisonStatus = "File Too Large to Process"
                            }
                        }
                    } else {
                        Write-Warning "No files found in folder path: $($folderPath) matching pattern: *.xlsx"
                    }

                    # Update the row with new column values
                    $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue $fileStatus -Force
                    $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "$($fileSizeKB) KB" -Force
                    $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue $fileComparisonStatus -Force

                    # Add updated row to the list
                    $updatedRows += $row
                } else {
                    Write-Warning "Folder path $($folderPath) does not exist."

                    # Update the rows with new column values for non-existent folder
                    foreach ($row in $rows) {
                        $row | Add-Member -NotePropertyName "File Status" -NotePropertyValue "File Not Found" -Force
                        $row | Add-Member -NotePropertyName "File Size" -NotePropertyValue "0 KB" -Force
                        $row | Add-Member -NotePropertyName "File Comparison Status" -NotePropertyValue "Data Not Found" -Force
                        $updatedRows += $row
                    }
                }
            }

            # Export the updated CSV
            $updatedRows | Export-Csv -Path $inputCSVPath -NoTypeInformation
        } else {
            Write-Warning "Required columns 'FolderPath', 'Output Filename(s)', 'JobName', 'FeedId', and/or 'Description' not found in the CSV file."
        }
    } else {
        Write-Warning "Input CSV path $inputCSVPath does not exist."
    }
}

# Process BAU Input CSV
Process-InputCSV -inputCSVPath $bauInputCSVPath -destinationPath $bauDestinationPath -folders $bauFolders

# Process CONV4 Input CSV
Process-InputCSV -inputCSVPath $conv4InputCSVPath -destinationPath $conv4DestinationPath -folders $conv4Folders

# Process BAU Input CSV
Process-InputCSV -inputCSVPath $bauInputCSVPath -destinationPath $bauDestinationPath -folders $bauFolders

# Process CONV4 Input CSV
Process-InputCSV -inputCSVPath $conv4InputCSVPath -destinationPath $conv4DestinationPath -folders $conv4Folders
